//Trying to avoid any npm installs or anything that takes extra time...
const https = require('https'),
    zlib = require('zlib'),
    fs = require('fs'),
    env = process.env;

function fail(message, exitCode = 1) {
    console.log(`::error::${message}`);
    process.exit(1);
}

function request(method, path, data, callback) {

    try {
        if (data) {
            data = JSON.stringify(data);
        }
        const options = {
            hostname: 'api.github.com',
            port: 443,
            path,
            method,
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': data ? data.length : 0,
                'Accept-Encoding': 'gzip',
                'Authorization': `token ${env.INPUT_TOKEN}`,
                'User-Agent': 'GitHub Action - development'
            }
        }
        const req = https.request(options, res => {

            let chunks = [];
            res.on('data', d => chunks.push(d));
            res.on('end', () => {
                let buffer = Buffer.concat(chunks);
                if (res.headers['content-encoding'] === 'gzip') {
                    zlib.gunzip(buffer, (err, decoded) => {
                        if (err) {
                            callback(err);
                        } else {
                            callback(null, res.statusCode, decoded && JSON.parse(decoded));
                        }
                    });
                } else {
                    callback(null, res.statusCode, buffer.length > 0 ? JSON.parse(buffer) : null);
                }
            });

            req.on('error', err => callback(err));
        });

        if (data) {
            req.write(data);
        }
        req.end();
    } catch (err) {
        callback(err);
    }
}

function generateBuildDate() {
    const o_date = new Intl.DateTimeFormat('en-us');
    const f_date = (m_ca, m_it) => Object({ ...m_ca, [m_it.type]: m_it.value });
    const m_date = o_date.formatToParts().reduce(f_date, {});
    return `${m_date.year}.${m_date.month}`;
}

function setGithubEnv(variable, value) {
    fs.writeFileSync(
        env['GITHUB_ENV'],
        `${variable}=${value}\n`,
        {
            flag: "a+"
        }
    );
}

function main() {

    //Some sanity checking:
    for (let varName of ['INPUT_TOKEN', 'INPUT_PREFIX', 'GITHUB_REPOSITORY', 'GITHUB_SHA', 'GITHUB_ENV', 'GITHUB_OUTPUT']) {
        if (!env[varName]) {
            fail(`ERROR: Environment variable ${varName} is not defined.`);
        }
    }

    const prefix = env.INPUT_PREFIX;
    const path = 'BUILD_NUMBER/BUILD_NUMBER';
    const date = generateBuildDate();

    //See if we've already generated the build number and are in later steps...
    if (fs.existsSync(path)) {
        let buildNumber = fs.readFileSync(path);
        console.log(`Build number already generated in earlier jobs, using build number ${buildNumber}...`);
        //Setting the output and a environment variable to new build number...
        setGithubEnv("BUILD_NUMBER", buildNumber);
        console.log(`::set-output name=build_number::${buildNumber}`);
        return;
    }

    request('GET', `/repos/${env.GITHUB_REPOSITORY}/git/refs/tags/${prefix}.${date}`, null, (err, status, result) => {

        let nextBuildNumber;
        let prefixedBuilderNumber;

        if (status === 404) {
            console.log('No existing tags for this month, starting at 0.');
            nextBuildNumber = `${date}.0.0`;
        } else if (status === 200) {
            const regexString = `/${prefix}\\.${date}\\.(\\d+)\\.(\\d+)$`;
            const regex = new RegExp(regexString);
            const nrTags = result.filter(d => d.ref.match(regex));

            //Existing version numbers:
            let version_numbers = nrTags.map(t => parseInt(t.ref.match(new RegExp(prefix + "\\.\\d+\\.\\d+\\.(\\d+)\\.(\\d+)$"))[1]));
            let currentVersionNumber = Math.max(...version_numbers);

            console.log(`Last autogenerated build number was ${prefix}.${date}.${currentVersionNumber}.0`);
            nextBuildNumber = `${date}.${currentVersionNumber + 1}.0`;

        } else {
            if (err) {
                fail(`Failed to get refs. Error: ${err}, status: ${status}`);
            } else {
                fail(`Getting build number refs failed with http status ${status}, error: ${JSON.stringify(result)}`);
            }
        }

        prefixedBuilderNumber = `${prefix}.${nextBuildNumber.toString()}`;
        console.log(`Updating build number to ${prefixedBuilderNumber}`);

        let newRefData = {
            ref: `refs/tags/${prefixedBuilderNumber}`,
            sha: env.GITHUB_SHA
        };

        request('POST', `/repos/${env.GITHUB_REPOSITORY}/git/refs`, newRefData, (err, status, result) => {
            if (status !== 201 || err) {
                fail(`Failed to create new build-number ref. Status: ${status}, err: ${err}, result: ${JSON.stringify(result)}`);
            }

            console.log(`Successfully created ref (tag) ${prefixedBuilderNumber}`);

            //Setting an environment variable to new build number...
            setGithubEnv("BUILD_NUMBER", prefixedBuilderNumber);
            //Setting output to new build number...
            fs.writeFileSync(env.GITHUB_OUTPUT, `BUILD_NUMBER=${prefixedBuilderNumber}`)
            //Save to file so it can be used for next jobs...
            fs.writeFileSync('BUILD_NUMBER', prefixedBuilderNumber.toString());
        });
    });
}

main();
